# pylint: skip-file
# fmt: off
r"""The anomalous dimension :math:`\gamma_{gg}^{(3)}`."""
import numba as nb
import numpy as np

from ...harmonics.log_functions import lm11, lm11m1


@nb.njit(cache=True)
def gamma_gg_nf3(n, sx):
    r"""Implement the part proportional to :math:`nf^3` of :math:`\gamma_{gg}^{(3)}`.

    The expression is copied exact from Eq. 3.14 of :cite:`Davies:2016jie`.

    Parameters
    ----------
    n : complex
        Mellin moment
    sx : list
        harmonic sums cache

    Returns
    -------
    complex
        |N3LO| non-singlet anomalous dimension :math:`\gamma_{gg}^{(3)}|_{nf^3}`

    """
    S1 = sx[0][0]
    S2 = sx[1][0]
    S3, S21, _, _, _, _ = sx[2]
    return 3.0 * (
        -0.0205761316872428
        + 2.599239604033225 / (-1.0 + n)
        - 1.1851851851851851 / np.power(n, 4)
        - 3.753086419753086 / np.power(n, 3)
        - 5.679012345679013 / np.power(n, 2)
        - 2.8050009209056537 / n
        - 1.1851851851851851 / np.power(1.0 + n, 4)
        + 3.753086419753086 / np.power(1.0 + n, 3)
        - 5.679012345679013 / np.power(1.0 + n, 2)
        + 2.8050009209056537 / (1.0 + n)
        - 2.599239604033225 / (2.0 + n)
        + 2.454258338353606 * S1
        - (8.674897119341564 * S1) / (-1.0 + n)
        + (2.3703703703703702 * S1) / np.power(n, 3)
        + (7.506172839506172 * S1) / np.power(n, 2)
        + (7.901234567901234 * S1) / n
        - (2.3703703703703702 * S1) / np.power(1.0 + n, 3)
        + (7.506172839506172 * S1) / np.power(1.0 + n, 2)
        - (7.901234567901234 * S1) / (1.0 + n)
        + (8.674897119341564 * S1) / (2.0 + n)
        - (2.567901234567901 * S2) / (-1.0 + n)
        + (2.3703703703703702 * S2) / np.power(n, 2)
        + (1.6296296296296295 * S2) / n
        + (2.3703703703703702 * S2) / np.power(1.0 + n, 2)
        - (1.6296296296296295 * S2) / (1.0 + n)
        + (2.567901234567901 * S2) / (2.0 + n)
        + (2.567901234567901 * (np.power(S1, 2) + S2)) / (-1.0 + n)
        - (2.3703703703703702 * (np.power(S1, 2) + S2)) / np.power(n, 2)
        - (1.6296296296296295 * (np.power(S1, 2) + S2)) / n
        - (2.3703703703703702 * (np.power(S1, 2) + S2)) / np.power(1.0 + n, 2)
        + (1.6296296296296295 * (np.power(S1, 2) + S2)) / (1.0 + n)
        - (2.567901234567901 * (np.power(S1, 2) + S2)) / (2.0 + n)
    ) + 1.3333333333333333 * (
        -0.6337448559670782
        - 54.23172286962781 / (-1.0 + n)
        + 3.5555555555555554 / np.power(n, 5)
        + 13.62962962962963 / np.power(n, 4)
        + 27.65432098765432 / np.power(n, 3)
        + 61.00190529209603 / np.power(n, 2)
        + 26.28917081074211 / n
        + 10.666666666666666 / np.power(1.0 + n, 5)
        - 31.40740740740741 / np.power(1.0 + n, 4)
        + 31.604938271604937 / np.power(1.0 + n, 3)
        - 12.479576189385448 / np.power(1.0 + n, 2)
        + 44.82194030036901 / (1.0 + n)
        - 16.879388241483305 / (2.0 + n)
        + (48.724279835390945 * S1) / (-1.0 + n)
        - (7.111111111111111 * S1) / np.power(n, 4)
        - (27.25925925925926 * S1) / np.power(n, 3)
        - (36.34567901234568 * S1) / np.power(n, 2)
        - (56.49382716049383 * S1) / n
        + (7.111111111111111 * S1) / np.power(1.0 + n, 4)
        - (17.77777777777778 * S1) / np.power(1.0 + n, 3)
        + (3.950617283950617 * S1) / np.power(1.0 + n, 2)
        + (4.345679012345679 * S1) / (1.0 + n)
        + (3.4238683127572016 * S1) / (2.0 + n)
        + (27.65432098765432 * S2) / (-1.0 + n)
        - (7.111111111111111 * S2) / np.power(n, 3)
        - (27.25925925925926 * S2) / np.power(n, 2)
        - (16.59259259259259 * S2) / n
        + (7.111111111111111 * S2) / np.power(1.0 + n, 3)
        - (27.25925925925926 * S2) / np.power(1.0 + n, 2)
        + (16.59259259259259 * S2) / (1.0 + n)
        - (27.65432098765432 * S2) / (2.0 + n)
        - (15.012345679012345 * (np.power(S1, 2) + S2)) / (-1.0 + n)
        + (7.111111111111111 * (np.power(S1, 2) + S2)) / np.power(n, 3)
        + (8.296296296296296 * (np.power(S1, 2) + S2)) / np.power(n, 2)
        + (22.51851851851852 * (np.power(S1, 2) + S2)) / n
        + (4.7407407407407405 * (np.power(S1, 2) + S2)) / np.power(1.0 + n, 2)
        - (15.407407407407407 * (np.power(S1, 2) + S2)) / (1.0 + n)
        + (7.901234567901234 * (np.power(S1, 2) + S2)) / (2.0 + n)
        - (9.481481481481481 * S21) / (-1.0 + n)
        + (14.222222222222221 * S21) / np.power(n, 2)
        + (21.333333333333332 * S21) / n
        + (14.222222222222221 * S21) / np.power(1.0 + n, 2)
        - (21.333333333333332 * S21) / (1.0 + n)
        - (28.444444444444443 * S21) / (n * (1.0 + n))
        + (9.481481481481481 * S21) / (2.0 + n)
        + (4.7407407407407405 * S3) / (-1.0 + n)
        - (7.111111111111111 * S3) / np.power(n, 2)
        - (10.666666666666666 * S3) / n
        - (7.111111111111111 * S3) / np.power(1.0 + n, 2)
        + (10.666666666666666 * S3) / (1.0 + n)
        + (14.222222222222221 * S3) / (n * (1.0 + n))
        - (4.7407407407407405 * S3) / (2.0 + n)
        - (9.481481481481481 * (S1 * S2 - 1.0 * S21 + S3)) / (-1.0 + n)
        + (14.222222222222221 * (S1 * S2 - 1.0 * S21 + S3)) / np.power(n, 2)
        + (21.333333333333332 * (S1 * S2 - 1.0 * S21 + S3)) / n
        + (14.222222222222221 * (S1 * S2 - 1.0 * S21 + S3)) / np.power(1.0 + n, 2)
        - (21.333333333333332 * (S1 * S2 - 1.0 * S21 + S3)) / (1.0 + n)
        - (28.444444444444443 * (S1 * S2 - 1.0 * S21 + S3)) / (n * (1.0 + n))
        + (9.481481481481481 * (S1 * S2 - 1.0 * S21 + S3)) / (2.0 + n)
        + (1.5802469135802468 * (np.power(S1, 3) + 3.0 * S1 * S2 + 2.0 * S3))
        / (-1.0 + n)
        - (2.3703703703703702 * (np.power(S1, 3) + 3.0 * S1 * S2 + 2.0 * S3))
        / np.power(n, 2)
        - (3.5555555555555554 * (np.power(S1, 3) + 3.0 * S1 * S2 + 2.0 * S3)) / n
        - (2.3703703703703702 * (np.power(S1, 3) + 3.0 * S1 * S2 + 2.0 * S3))
        / np.power(1.0 + n, 2)
        + (3.5555555555555554 * (np.power(S1, 3) + 3.0 * S1 * S2 + 2.0 * S3))
        / (1.0 + n)
        + (4.7407407407407405 * (np.power(S1, 3) + 3.0 * S1 * S2 + 2.0 * S3))
        / (n * (1.0 + n))
        - (1.5802469135802468 * (np.power(S1, 3) + 3.0 * S1 * S2 + 2.0 * S3))
        / (2.0 + n)
    )


@nb.njit(cache=True)
def gamma_gg_nf1(n, sx, variation):
    r"""Implement the part proportional to :math:`nf^1` of :math:`\gamma_{gg}^{(3)}`.

    Parameters
    ----------
    n : complex
        Mellin moment
    sx : list
        harmonic sums cache
    variation : int
        |N3LO| anomalous dimension variation

    Returns
    -------
    complex
        |N3LO| non-singlet anomalous dimension :math:`\gamma_{gg}^{(3)}|_{nf^1}`

    """
    S1 = sx[0][0]
    common = 1992.766087237516/np.power(-1. + n,3) + 20005.925925925927/np.power(n,7) - 19449.679012345678/np.power(n,6) + 80274.123066115/np.power(n,5) - 11714.245609287387*S1
    if variation == 1:
        fit = 20376.922865394186 - 1922.4203505287257/np.power(-1. + n,2) + 89847.85054987555/(1. + n) + 46042.24311216136*lm11(n,S1)
    elif variation == 2:
        fit = 18330.917702197996 - 3215.823175662521/np.power(-1. + n,2) + 79596.90186068034/np.power(1. + n,2) + 13449.454714544168*lm11(n,S1)
    elif variation == 3:
        fit = 17432.587453247663 - 5888.588070341448/np.power(-1. + n,2) + 239415.56587043975/np.power(1. + n,3) + 8718.851821231023*lm11(n,S1)
    elif variation == 4:
        fit = 18332.425007563226 - 4155.222196167377/np.power(-1. + n,2) + (26928.410939476464*S1)/np.power(n,2) + 13871.004288439888*lm11(n,S1)
    elif variation == 5:
        fit = 19217.48317304973 - 2224.603819919205/np.power(-1. + n,2) + 19364.9188791179*lm11(n,S1) - 82100.97722575821*lm11m1(n,S1)
    elif variation == 6:
        fit = 18371.822909262337 - 10452.576219114608/np.power(-1. + n,2) + 19915.74905225982/(-1. + n) + 18617.189393383927*lm11(n,S1)
    elif variation == 7:
        fit = 18825.78155198363 + 56912.83405264956/np.power(-1. + n,2) - 809336.4979043411/np.power(n,4) + 15043.974384322988*lm11(n,S1)
    elif variation == 8:
        fit = 16822.610589552198 - 21380.14521455183/np.power(-1. + n,2) + 183938.47846507264/np.power(n,3) + 6083.561981019736*lm11(n,S1)
    elif variation == 9:
        fit = 17804.835317102905 - 6696.858908152799/np.power(-1. + n,2) + 43449.45265885665/np.power(n,2) + 10797.64783505956*lm11(n,S1)
    elif variation == 10:
        fit = 18941.917199925203 - 3642.1683755666895/np.power(-1. + n,2) + 34902.06004633214/n + 25171.566866873323*lm11(n,S1)
    elif variation == 11:
        fit = 17010.683346191287 - 16243.176631021093/np.power(-1. + n,2) + 33435.33139543277/(-1. + n) - 60992.203239700044/(1. + n)
    elif variation == 12:
        fit = 17268.851402232438 - 11725.235650302498/np.power(-1. + n,2) + 22097.450934296354/(-1. + n) - 55075.851955426624/(2. + n)
    elif variation == 13:
        fit = 18224.45853504099 + 15618.422076284627/np.power(-1. + n,2) - 51832.375621261235/(-1. + n) + 286754.38836574735/np.power(1. + n,2)
    elif variation == 14:
        fit = 16605.271279542245 - 1868.444678287428/np.power(-1. + n,2) - 17542.58870539885/(-1. + n) + 450302.3766408688/np.power(1. + n,3)
    elif variation == 15:
        fit = 18217.28232953059 + 14249.164216646603/np.power(-1. + n,2) - 58204.94447712575/(-1. + n) + (105628.2710088485*S1)/np.power(n,2)
    elif variation == 16:
        fit = -2683.6758957879742 - 215315.06111735682/np.power(-1. + n,2) + 515783.9461617711/(-1. + n) + 2.0441743592490472e6*lm11m1(n,S1)
    elif variation == 17:
        fit = 20737.041348925653 + 340535.14727711474/np.power(-1. + n,2) - 83849.42350996069/(-1. + n) - 4.216810582699363e6/np.power(n,4)
    elif variation == 18:
        fit = 16070.655161276209 - 26684.1598544024/np.power(-1. + n,2) - 9666.690238321324/(-1. + n) + 273218.3890305371/np.power(n,3)
    elif variation == 19:
        fit = 17021.908044280008 - 1510.7603895474747/np.power(-1. + n,2) - 27500.748353823/(-1. + n) + 103446.81758584038/np.power(n,2)
    elif variation == 20:
        fit = 16752.515290150266 - 29796.999573176807/np.power(-1. + n,2) + 76484.85474027973/(-1. + n) - 99136.53351976715/n
    else:
        fit = 16984.114730533038 + 3229.6661699297897/np.power(-1. + n,2) + 20956.028068907446/(-1. + n) - 251307.3540301852/np.power(n,4) + 22857.84337478049/np.power(n,3) + 7344.813512234853/np.power(n,2) - 3211.723673671751/n + 34485.897125565425/np.power(1. + n,3) + 18317.564511321387/np.power(1. + n,2) + 1442.7823655087757/(1. + n) - 2753.792597771331/(2. + n) + (6627.834097416248*S1)/np.power(n,2) + 8858.020663807692*lm11(n,S1) + 98103.66910116446*lm11m1(n,S1)
    return common + fit


@nb.njit(cache=True)
def gamma_gg_nf2(n, sx, variation):
    r"""Implement the part proportional to :math:`nf^2` of :math:`\gamma_{gg}^{(3)}`.

    Parameters
    ----------
    n : complex
        Mellin moment
    sx : list
        harmonic sums cache
    variation : int
        |N3LO| anomalous dimension variation

    Returns
    -------
    complex
        |N3LO| non-singlet anomalous dimension :math:`\gamma_{gg}^{(3)}|_{nf^2}`

    """
    S1 = sx[0][0]
    common = -568.8888888888889/np.power(n,7) + 1725.6296296296296/np.power(n,6) - 2196.543209876543/np.power(n,5) + 440.0487580115612*S1
    if variation == 1:
        fit = -509.5030380242717 - 293.5797549498581/np.power(-1. + n,2) - 3285.5058360343082/(1. + n) - 1384.92147329284*lm11(n,S1)
    elif variation == 2:
        fit = -434.6858680742132 - 246.28332543804558/np.power(-1. + n,2) - 2910.6548903842818/np.power(1. + n,2) - 193.08665657054635*lm11(n,S1)
    elif variation == 3:
        fit = -401.8362310762296 - 148.5471569479592/np.power(-1. + n,2) - 8754.814211922745/np.power(1. + n,3) - 20.100621636819284*lm11(n,S1)
    elif variation == 4:
        fit = -434.7409863719113 - 211.93190862234567/np.power(-1. + n,2) - (984.7030369153432*S1)/np.power(n,2) - 208.5016450954338*lm11(n,S1)
    elif variation == 5:
        fit = -467.1052972612572 - 282.52967922563107/np.power(-1. + n,2) - 409.4000343153979*lm11(n,S1) + 3002.2225147122917*lm11m1(n,S1)
    elif variation == 6:
        fit = -436.1816667573366 + 18.346203400839386/np.power(-1. + n,2) - 728.26794786671/(-1. + n) - 382.0574816096947*lm11(n,S1)
    elif variation == 7:
        fit = -452.7817719446178 - 2445.0343587402526/np.power(-1. + n,2) + 29595.363393853604/np.power(n,4) - 251.3941580707783*lm11(n,S1)
    elif variation == 8:
        fit = -379.53093903805467 + 417.93942114004517/np.power(-1. + n,2) - 6726.15917653794/np.power(n,3) + 76.26518006757968*lm11(n,S1)
    elif variation == 9:
        fit = -415.4483823036964 - 118.99076201504342/np.power(-1. + n,2) - 1588.8352298859174/np.power(n,2) - 96.11686903237798*lm11(n,S1)
    elif variation == 10:
        fit = -457.0285552204402 - 230.69297314939442/np.power(-1. + n,2) - 1276.2789679446958/n - 621.7342831016634*lm11(n,S1)
    elif variation == 11:
        fit = -408.24868812141733 + 137.17951188977668/np.power(-1. + n,2) - 1005.7135640284582/(-1. + n) + 1251.66732073249/(1. + n)
    elif variation == 12:
        fit = -413.54675085467966 + 44.463414057745524/np.power(-1. + n,2) - 773.0403089928385/(-1. + n) + 1130.253383095342/(2. + n)
    elif variation == 13:
        fit = -433.1574905240533 - 516.67655117943/np.power(-1. + n,2) + 744.1298047567468/(-1. + n) - 5884.704567622808/np.power(1. + n,2)
    elif variation == 14:
        fit = -399.9289192279905 - 157.81527881839813/np.power(-1. + n,2) + 40.44304747086977/(-1. + n) - 9240.997034891268/np.power(1. + n,3)
    elif variation == 15:
        fit = -433.01022216109607 - 488.5769708145494/np.power(-1. + n,2) + 874.9061296364304/(-1. + n) - (2167.677964471257*S1)/np.power(n,2)
    elif variation == 16:
        fit = -4.085786035829887 + 4222.4848304881125/np.power(-1. + n,2) - 10904.355787705801/(-1. + n) - 41950.0543913106*lm11m1(n,S1)
    elif variation == 17:
        fit = -484.7201105267116 - 7184.53941383117/np.power(-1. + n,2) + 1401.1759585269126/(-1. + n) + 86536.37225304058/np.power(n,4)
    elif variation == 18:
        fit = -388.9576558725636 + 351.44685759725786/np.power(-1. + n,2) - 121.18424600312078/(-1. + n) - 5606.92204590008/np.power(n,3)
    elif variation == 19:
        fit = -408.4790386750365 - 165.15558973643385/np.power(-1. + n,2) + 244.80200393591616/(-1. + n) - 2122.9107021615287/np.power(n,2)
    elif variation == 20:
        fit = -402.9506253881587 + 415.3278053858821/np.power(-1. + n,2) - 1889.1655247994265/(-1. + n) + 2034.4560895715347/n
    else:
        fit = -408.29640117297834 - 344.15828397544266/np.power(-1. + n,2) - 605.813521753474/(-1. + n) + 5806.58678234471/np.power(n,4) - 616.6540611219011/np.power(n,3) - 185.58729660237233/np.power(n,2) + 37.908856081341945/n - 899.7905623407007/np.power(1. + n,3) - 439.7679729003545/np.power(1. + n,2) - 101.69192576509091/(1. + n) + 56.51266915476711/(2. + n) - (157.61905006933*S1)/np.power(n,2) - 174.5524021328986*lm11(n,S1) - 1947.3915938299158*lm11m1(n,S1)
    return common + fit


@nb.njit(cache=True)
def gamma_gg_nf0(n, sx, variation):
    r"""Implement the part proportional to :math:`nf^0` of :math:`\gamma_{gg}^{(3)}`.

    Parameters
    ----------
    n : complex
        Mellin moment
    sx : list
        harmonic sums cache
    variation : int
        |N3LO| anomalous dimension variation

    Returns
    -------
    complex
        |N3LO| non-singlet anomalous dimension :math:`\gamma_{gg}^{(3)}|_{nf^0}`

    """
    S1 = sx[0][0]
    common = -49851.703887834694/np.power(-1. + n,4) + 213823.9810748423/np.power(-1. + n,3) - 103680./np.power(n,7) - 17280./np.power(n,6) - 627978.8224813186/np.power(n,5) + 40880.33011934297*S1
    if variation == 1:
        fit = -52853.21429093597 - 203743.46165088296/np.power(-1. + n,2) + 400134.76324578153/(1. + n) + 108493.35018256328*lm11(n,S1)
    elif variation == 2:
        fit = -61965.03818616296 - 209503.59314038412/np.power(-1. + n,2) + 354482.4643683706/np.power(1. + n,2) - 36657.67557025561*lm11(n,S1)
    elif variation == 3:
        fit = -65965.72556243799 - 221406.67308941437/np.power(-1. + n,2) + 1.0662301900448292e6/np.power(1. + n,3) - 57725.2765995656*lm11(n,S1)
    elif variation == 4:
        fit = -61958.3254459946 - 213687.17908442733/np.power(-1. + n,2) + (119924.88712761062*S1)/np.power(n,2) - 34780.316925449675*lm11(n,S1)
    elif variation == 5:
        fit = -58016.74490357386 - 205089.2268555187/np.power(-1. + n,2) - 10313.329673338014*lm11(n,S1) - 365634.2904523784*lm11m1(n,S1)
    elif variation == 6:
        fit = -61782.86804804711 - 241732.26024802894/np.power(-1. + n,2) + 88694.20340182523/(-1. + n) - 13643.320974359944*lm11(n,S1)
    elif variation == 7:
        fit = -59761.1765672044 + 58277.61561519298/np.power(-1. + n,2) - 3.604356320080644e6/np.power(n,4) - 29556.529058093984*lm11(n,S1)
    elif variation == 8:
        fit = -68682.23960753088 - 290397.86778434116/np.power(-1. + n,2) + 819164.6108612537/np.power(n,3) - 69461.4624943125*lm11(n,S1)
    elif variation == 9:
        fit = -64307.930635114346 - 225006.28352357633/np.power(-1. + n,2) + 193500.8611381208/np.power(n,2) - 48467.41961423959*lm11(n,S1)
    elif variation == 10:
        fit = -59243.96987044947 - 211402.3089647515/np.power(-1. + n,2) + 155435.2992081357/n + 15546.406576463616*lm11(n,S1)
    elif variation == 11:
        fit = -60785.37784920544 - 237488.7077770018/np.power(-1. + n,2) + 78786.58536939032/(-1. + n) + 44697.19828000824/(1. + n)
    elif variation == 12:
        fit = -60974.57233927943 - 240799.61135329804/np.power(-1. + n,2) + 87095.37672514404/(-1. + n) + 40361.491215809925/(2. + n)
    elif variation == 13:
        fit = -61674.87433238988 - 260837.99046058886/np.power(-1. + n,2) + 141273.71331308625/(-1. + n) - 210143.544152296/np.power(1. + n,2)
    elif variation == 14:
        fit = -60488.27785009731 - 248023.00905135006/np.power(-1. + n,2) + 116144.9702385925/(-1. + n) - 329997.1725169001/np.power(1. + n,3)
    elif variation == 15:
        fit = -61669.61536052819 - 259834.55089293994/np.power(-1. + n,2) + 145943.7524094594/(-1. + n) - (77408.0541852593*S1)/np.power(n,2)
    elif variation == 16:
        fit = -46352.66951471771 - 91601.93831745796/np.power(-1. + n,2) - 274695.1799894809/(-1. + n) - 1.4980417463388646e6*lm11m1(n,S1)
    elif variation == 17:
        fit = -63516.18201209067 - 498948.2163482745/np.power(-1. + n,2) + 164736.91453894487/(-1. + n) + 3.090224794527035e6/np.power(n,4)
    elif variation == 18:
        fit = -60096.492648504915 - 229837.19377053817/np.power(-1. + n,2) + 110373.23915301856/(-1. + n) - 200223.8951796512/np.power(n,3)
    elif variation == 19:
        fit = -60793.60369659996 - 248285.1324823178/np.power(-1. + n,2) + 123442.65441242549/(-1. + n) - 75809.40958795448/np.power(n,2)
    elif variation == 20:
        fit = -60596.18335913143 - 227555.99704811012/np.power(-1. + n,2) + 47238.40414953011/(-1. + n) + 72650.68418846124/n
    else:
        fit = -60574.25410399983 - 225345.1793114005/np.power(-1. + n,2) + 41451.7316860968/(-1. + n) - 25706.57627768044/np.power(n,4) + 30947.035784080126/np.power(n,3) + 5884.572577508316/np.power(n,2) + 11404.299169829847/n + 36811.65087639645/np.power(1. + n,3) + 7216.94601080373/np.power(1. + n,2) + 22241.59807628949/(1. + n) + 2018.0745607904964/(2. + n) + (2125.841647117566*S1)/np.power(n,2) - 8828.278707529402*lm11(n,S1) - 93183.80183956215*lm11m1(n,S1)
    return common + fit


@nb.njit(cache=True)
def gamma_gg(n, nf, sx, variation):
    r"""Compute the |N3LO| gluon-gluon singlet anomalous dimension.

    Parameters
    ----------
    n : complex
        Mellin moment
    nf : int
        Number of active flavors
    sx : list
        harmonic sums cache
    variation : int
        |N3LO| anomalous dimension variation

    Returns
    -------
    complex
        |N3LO| gluon-gluon singlet anomalous dimension
        :math:`\gamma_{gg}^{(3)}(N)`

    See Also
    --------
    gamma_gg_nf0: :math:`\gamma_{gg}^{(3)}|_{nf^0}`
    gamma_gg_nf1: :math:`\gamma_{gg}^{(3)}|_{nf^1}`
    gamma_gg_nf2: :math:`\gamma_{gg}^{(3)}|_{nf^2}`
    gamma_gg_nf3: :math:`\gamma_{gg}^{(3)}|_{nf^3}`

    """
    return (
        gamma_gg_nf0(n, sx, variation)
        + nf * gamma_gg_nf1(n, sx, variation)
        + nf**2 * gamma_gg_nf2(n, sx, variation)
        + nf**3 * gamma_gg_nf3(n, sx)
    )
