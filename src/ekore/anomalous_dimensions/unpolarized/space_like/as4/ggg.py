# pylint: skip-file
# fmt: off
r"""The unpolarized, space-like anomalous dimension :math:`\gamma_{gg}^{(3)}`."""
import numba as nb
import numpy as np

from .....harmonics import cache as c
from .....harmonics.log_functions import lm11, lm11m1, lm12m1, lm13m1


@nb.njit(cache=True)
def gamma_gg_nf3(n, cache):
    r"""Return the part proportional to :math:`nf^3` of :math:`\gamma_{gg}^{(3)}`.

    The expression is copied exact from :eqref:`3.14` of :cite:`Davies:2016jie`.

    Parameters
    ----------
    n : complex
        Mellin moment
    cache: numpy.ndarray
        Harmonic sum cache

    Returns
    -------
    complex
        |N3LO| non-singlet anomalous dimension :math:`\gamma_{gg}^{(3)}|_{nf^3}`

    """
    S1 = c.get(c.S1, cache, n)
    S2 = c.get(c.S2, cache, n)
    S3=  c.get(c.S3, cache, n)
    S21 = c.get(c.S21, cache, n)
    return 3.0 * (
        -0.0205761316872428
        + 2.599239604033225 / (-1.0 + n)
        - 1.1851851851851851 / np.power(n, 4)
        - 3.753086419753086 / np.power(n, 3)
        - 5.679012345679013 / np.power(n, 2)
        - 2.8050009209056537 / n
        - 1.1851851851851851 / np.power(1.0 + n, 4)
        + 3.753086419753086 / np.power(1.0 + n, 3)
        - 5.679012345679013 / np.power(1.0 + n, 2)
        + 2.8050009209056537 / (1.0 + n)
        - 2.599239604033225 / (2.0 + n)
        + 2.454258338353606 * S1
        - (8.674897119341564 * S1) / (-1.0 + n)
        + (2.3703703703703702 * S1) / np.power(n, 3)
        + (7.506172839506172 * S1) / np.power(n, 2)
        + (7.901234567901234 * S1) / n
        - (2.3703703703703702 * S1) / np.power(1.0 + n, 3)
        + (7.506172839506172 * S1) / np.power(1.0 + n, 2)
        - (7.901234567901234 * S1) / (1.0 + n)
        + (8.674897119341564 * S1) / (2.0 + n)
        - (2.567901234567901 * S2) / (-1.0 + n)
        + (2.3703703703703702 * S2) / np.power(n, 2)
        + (1.6296296296296295 * S2) / n
        + (2.3703703703703702 * S2) / np.power(1.0 + n, 2)
        - (1.6296296296296295 * S2) / (1.0 + n)
        + (2.567901234567901 * S2) / (2.0 + n)
        + (2.567901234567901 * (np.power(S1, 2) + S2)) / (-1.0 + n)
        - (2.3703703703703702 * (np.power(S1, 2) + S2)) / np.power(n, 2)
        - (1.6296296296296295 * (np.power(S1, 2) + S2)) / n
        - (2.3703703703703702 * (np.power(S1, 2) + S2)) / np.power(1.0 + n, 2)
        + (1.6296296296296295 * (np.power(S1, 2) + S2)) / (1.0 + n)
        - (2.567901234567901 * (np.power(S1, 2) + S2)) / (2.0 + n)
    ) + 1.3333333333333333 * (
        -0.6337448559670782
        - 54.23172286962781 / (-1.0 + n)
        + 3.5555555555555554 / np.power(n, 5)
        + 13.62962962962963 / np.power(n, 4)
        + 27.65432098765432 / np.power(n, 3)
        + 61.00190529209603 / np.power(n, 2)
        + 26.28917081074211 / n
        + 10.666666666666666 / np.power(1.0 + n, 5)
        - 31.40740740740741 / np.power(1.0 + n, 4)
        + 31.604938271604937 / np.power(1.0 + n, 3)
        - 12.479576189385448 / np.power(1.0 + n, 2)
        + 44.82194030036901 / (1.0 + n)
        - 16.879388241483305 / (2.0 + n)
        + (48.724279835390945 * S1) / (-1.0 + n)
        - (7.111111111111111 * S1) / np.power(n, 4)
        - (27.25925925925926 * S1) / np.power(n, 3)
        - (36.34567901234568 * S1) / np.power(n, 2)
        - (56.49382716049383 * S1) / n
        + (7.111111111111111 * S1) / np.power(1.0 + n, 4)
        - (17.77777777777778 * S1) / np.power(1.0 + n, 3)
        + (3.950617283950617 * S1) / np.power(1.0 + n, 2)
        + (4.345679012345679 * S1) / (1.0 + n)
        + (3.4238683127572016 * S1) / (2.0 + n)
        + (27.65432098765432 * S2) / (-1.0 + n)
        - (7.111111111111111 * S2) / np.power(n, 3)
        - (27.25925925925926 * S2) / np.power(n, 2)
        - (16.59259259259259 * S2) / n
        + (7.111111111111111 * S2) / np.power(1.0 + n, 3)
        - (27.25925925925926 * S2) / np.power(1.0 + n, 2)
        + (16.59259259259259 * S2) / (1.0 + n)
        - (27.65432098765432 * S2) / (2.0 + n)
        - (15.012345679012345 * (np.power(S1, 2) + S2)) / (-1.0 + n)
        + (7.111111111111111 * (np.power(S1, 2) + S2)) / np.power(n, 3)
        + (8.296296296296296 * (np.power(S1, 2) + S2)) / np.power(n, 2)
        + (22.51851851851852 * (np.power(S1, 2) + S2)) / n
        + (4.7407407407407405 * (np.power(S1, 2) + S2)) / np.power(1.0 + n, 2)
        - (15.407407407407407 * (np.power(S1, 2) + S2)) / (1.0 + n)
        + (7.901234567901234 * (np.power(S1, 2) + S2)) / (2.0 + n)
        - (9.481481481481481 * S21) / (-1.0 + n)
        + (14.222222222222221 * S21) / np.power(n, 2)
        + (21.333333333333332 * S21) / n
        + (14.222222222222221 * S21) / np.power(1.0 + n, 2)
        - (21.333333333333332 * S21) / (1.0 + n)
        - (28.444444444444443 * S21) / (n * (1.0 + n))
        + (9.481481481481481 * S21) / (2.0 + n)
        + (4.7407407407407405 * S3) / (-1.0 + n)
        - (7.111111111111111 * S3) / np.power(n, 2)
        - (10.666666666666666 * S3) / n
        - (7.111111111111111 * S3) / np.power(1.0 + n, 2)
        + (10.666666666666666 * S3) / (1.0 + n)
        + (14.222222222222221 * S3) / (n * (1.0 + n))
        - (4.7407407407407405 * S3) / (2.0 + n)
        - (9.481481481481481 * (S1 * S2 - 1.0 * S21 + S3)) / (-1.0 + n)
        + (14.222222222222221 * (S1 * S2 - 1.0 * S21 + S3)) / np.power(n, 2)
        + (21.333333333333332 * (S1 * S2 - 1.0 * S21 + S3)) / n
        + (14.222222222222221 * (S1 * S2 - 1.0 * S21 + S3)) / np.power(1.0 + n, 2)
        - (21.333333333333332 * (S1 * S2 - 1.0 * S21 + S3)) / (1.0 + n)
        - (28.444444444444443 * (S1 * S2 - 1.0 * S21 + S3)) / (n * (1.0 + n))
        + (9.481481481481481 * (S1 * S2 - 1.0 * S21 + S3)) / (2.0 + n)
        + (1.5802469135802468 * (np.power(S1, 3) + 3.0 * S1 * S2 + 2.0 * S3))
        / (-1.0 + n)
        - (2.3703703703703702 * (np.power(S1, 3) + 3.0 * S1 * S2 + 2.0 * S3))
        / np.power(n, 2)
        - (3.5555555555555554 * (np.power(S1, 3) + 3.0 * S1 * S2 + 2.0 * S3)) / n
        - (2.3703703703703702 * (np.power(S1, 3) + 3.0 * S1 * S2 + 2.0 * S3))
        / np.power(1.0 + n, 2)
        + (3.5555555555555554 * (np.power(S1, 3) + 3.0 * S1 * S2 + 2.0 * S3))
        / (1.0 + n)
        + (4.7407407407407405 * (np.power(S1, 3) + 3.0 * S1 * S2 + 2.0 * S3))
        / (n * (1.0 + n))
        - (1.5802469135802468 * (np.power(S1, 3) + 3.0 * S1 * S2 + 2.0 * S3))
        / (2.0 + n)
    )


@nb.njit(cache=True)
def gamma_gg_nf1(n, cache, variation):
    r"""Return the part proportional to :math:`nf^1` of :math:`\gamma_{gg}^{(3)}`.

    Parameters
    ----------
    n : complex
        Mellin moment
    cache: numpy.ndarray
        Harmonic sum cache
    variation : int
        |N3LO| anomalous dimension variation

    Returns
    -------
    complex
        |N3LO| non-singlet anomalous dimension :math:`\gamma_{gg}^{(3)}|_{nf^1}`

    """
    S1 = c.get(c.S1, cache, n)
    S2 = c.get(c.S2, cache, n)
    S3 = c.get(c.S3, cache, n)
    common = 18143.980574437464 + 1992.766087237516/np.power(-1. + n,3) + 20005.925925925927/np.power(n,7) - 19449.679012345678/np.power(n,6) + 80274.123066115/np.power(n,5) + 4341.13370266389/n - 11714.245609287387*S1 + 13880.514502193577*lm11(n,S1)
    if variation == 1:
        fit = -10270.11416182055/np.power(-1. + n,2) + 18731.17968740991/(-1. + n) + 297.3210929571657/(1. + n) - 23244.924485271466/(2. + n) - 4050.833138545348*lm13m1(n,S1,S2,S3)
    elif variation == 2:
        fit = -11082.13131236475/np.power(-1. + n,2) + 21010.979258355084/(-1. + n) - 21217.46135836648/(1. + n) + 8541.603641080774*lm12m1(n,S1,S2) + 1299.6826595628106*lm13m1(n,S1,S2,S3)
    elif variation == 3:
        fit = -2710.665352609663/np.power(-1. + n,2) + 22945.993521464054/(-1. + n) - 126229.56225118619/np.power(n,4) - 34046.95702168874/(1. + n) - 9872.686392323958*lm13m1(n,S1,S2,S3)
    elif variation == 4:
        fit = -11295.981203099282/np.power(-1. + n,2) + 29362.42506506866/(-1. + n) - 31878.254277368906/np.power(n,3) - 35458.54478982031/(1. + n) - 5668.488002948361*lm13m1(n,S1,S2,S3)
    elif variation == 5:
        fit = -10686.93631688797/np.power(-1. + n,2) + 19906.339608012637/(-1. + n) - 22367.39965022059/(1. + n) - 11221.684701529948*lm11m1(n,S1) - 2145.948106277924*lm13m1(n,S1,S2,S3)
    elif variation == 6:
        fit = -10281.335740623817/np.power(-1. + n,2) + 18762.685118697587/(-1. + n) - 22923.693890952152/(2. + n) + 118.0397215654495*lm12m1(n,S1,S2) - 3976.892293061728*lm13m1(n,S1,S2,S3)
    elif variation == 7:
        fit = -10204.671424181955/np.power(-1. + n,2) + 18767.66765933924/(-1. + n) - 1092.779160652895/np.power(n,4) - 23043.691361939706/(2. + n) - 4101.2333760090105*lm13m1(n,S1,S2,S3)
    elif variation == 8:
        fit = -10278.644563822769/np.power(-1. + n,2) + 18819.581783601687/(-1. + n) - 265.07755215895946/np.power(n,3) - 23051.635742762955/(2. + n) - 4064.284439480962*lm13m1(n,S1,S2,S3)
    elif variation == 9:
        fit = -10347.501508088137/np.power(-1. + n,2) + 19058.23126571671/(-1. + n) - 572.2668461573236/np.power(n,2) - 23256.742273946194/(2. + n) - 4035.759520905052*lm13m1(n,S1,S2,S3)
    elif variation == 10:
        fit = -10275.582132070176/np.power(-1. + n,2) + 18746.595709341593/(-1. + n) - 22939.992144309395/(2. + n) - 147.20867721931182*lm11m1(n,S1) - 4025.8444124078146*lm13m1(n,S1,S2,S3)
    elif variation == 11:
        fit = -24926.888750623133/np.power(-1. + n,2) + 17810.84642127126/(-1. + n) + 208758.85768476047/np.power(n,4) + 22667.73532614404*lm12m1(n,S1,S2) + 19776.5826765651*lm13m1(n,S1,S2,S3)
    elif variation == 12:
        fit = -10763.5212982461/np.power(-1. + n,2) + 8568.352997277027/(-1. + n) + 47494.674935205614/np.power(n,3) + 21267.541668576003*lm12m1(n,S1,S2) + 11681.399225017101*lm13m1(n,S1,S2,S3)
    elif variation == 13:
        fit = -5727.151193148642/np.power(-1. + n,2) - 1579.7328323989361/(-1. + n) + 39389.08181155469/np.power(n,2) + 8242.704431969565*lm12m1(n,S1,S2) + 74.93434922328093*lm13m1(n,S1,S2,S3)
    elif variation == 14:
        fit = -18373.856968226213/np.power(-1. + n,2) + 41392.63735393215/(-1. + n) + 207050.815868518*lm11m1(n,S1) + 166142.36054620336*lm12m1(n,S1,S2) + 64874.865907564*lm13m1(n,S1,S2,S3)
    elif variation == 15:
        fit = 5243.900655452294/np.power(-1. + n,2) - 12659.834824913609/(-1. + n) - 119288.31030415706/np.power(n,4) + 61896.66336205812/np.power(n,2) - 11182.917725840534*lm13m1(n,S1,S2,S3)
    elif variation == 16:
        fit = -25962.210430671832/np.power(-1. + n,2) + 14085.129803728569/(-1. + n) + 241740.93047797284/np.power(n,4) - 32712.217132272293*lm11m1(n,S1) + 12651.448553539236*lm13m1(n,S1,S2,S3)
    elif variation == 17:
        fit = -2539.909047069818/np.power(-1. + n,2) - 8001.899230702169/(-1. + n) - 30056.772339779138/np.power(n,3) + 64316.26925516245/np.power(n,2) - 7270.160083308018*lm13m1(n,S1,S2,S3)
    elif variation == 18:
        fit = -9646.328315869272/np.power(-1. + n,2) + 3749.766574153606/(-1. + n) + 54466.866417785626/np.power(n,3) - 30394.942945299434*lm11m1(n,S1) + 3872.6283293477754*lm13m1(n,S1,S2,S3)
    elif variation == 19:
        fit = -5066.965729118176/np.power(-1. + n,2) - 3822.9837355590003/(-1. + n) + 41445.27729170122/np.power(n,2) - 10808.501548399454*lm11m1(n,S1) - 3307.7625874988926*lm13m1(n,S1,S2,S3)
    else:
        fit = -10273.4997259521/np.power(-1. + n,2) + 13981.787431778737/(-1. + n) + 10731.007181407218/np.power(n,4) + 2092.707220193907/np.power(n,3) + 10867.106572332586/np.power(n,2) - 5936.475880375734/(1. + n) - 7287.404205220098/(2. + n) + 6408.750571778819*lm11m1(n,S1) + 11946.315017659957*lm12m1(n,S1,S2) + 2659.4069274848257*lm13m1(n,S1,S2,S3)
    return common + fit



@nb.njit(cache=True)
def gamma_gg_nf2(n, cache, variation):
    r"""Return the part proportional to :math:`nf^2` of :math:`\gamma_{gg}^{(3)}`.

    Parameters
    ----------
    n : complex
        Mellin moment
    cache: numpy.ndarray
        Harmonic sum cache
    variation : int
        |N3LO| anomalous dimension variation

    Returns
    -------
    complex
        |N3LO| non-singlet anomalous dimension :math:`\gamma_{gg}^{(3)}|_{nf^2}`

    """
    S1 = c.get(c.S1, cache, n)
    S2 = c.get(c.S2, cache, n)
    S3 = c.get(c.S3, cache, n)
    common = -423.811346198137 - 568.8888888888889/np.power(n,7) + 1725.6296296296296/np.power(n,6) - 2196.543209876543/np.power(n,5) + 21.333333333333336/n + 440.0487580115612*S1 - 135.11111111111114*lm11(n,S1)
    if variation == 1:
        fit = -16.959956452231857/np.power(-1. + n,2) - 629.5045317989062/(-1. + n) - 682.6697400582308/(1. + n) + 1217.639625778457/(2. + n) - 72.64979891934051*lm13m1(n,S1,S2,S3)
    elif variation == 2:
        fit = 25.57596402110471/np.power(-1. + n,2) - 748.9273459351353/(-1. + n) + 444.33979999567083/(1. + n) - 447.4350978280687*lm12m1(n,S1,S2) - 352.92603979329243*lm13m1(n,S1,S2,S3)
    elif variation == 3:
        fit = -412.9468061824264/np.power(-1. + n,2) - 850.2892602188854/(-1. + n) + 6612.287213025851/np.power(n,4) + 1116.3876833223574/(1. + n) + 232.31652703107594*lm13m1(n,S1,S2,S3)
    elif variation == 4:
        fit = 36.77806971484529/np.power(-1. + n,2) - 1186.401399819004/(-1. + n) + 1669.8796175207788/np.power(n,3) + 1190.3309307108536/(1. + n) + 12.087867790598803*lm13m1(n,S1,S2,S3)
    elif variation == 5:
        fit = 4.874451882150377/np.power(-1. + n,2) - 691.0629716579465/(-1. + n) + 504.5770544662291/(1. + n) + 587.8258700832249*lm11m1(n,S1) - 172.43345273623754*lm13m1(n,S1,S2,S3)
    elif variation == 6:
        fit = 8.805562596792123/np.power(-1. + n,2) - 701.843175427027/(-1. + n) + 480.0720211823408/(2. + n) - 271.02734366604454*lm12m1(n,S1,S2) - 242.4230809561374*lm13m1(n,S1,S2,S3)
    elif variation == 7:
        fit = -167.2209966272019/np.power(-1. + n,2) - 713.2834324613012/(-1. + n) + 2509.096338027503/np.power(n,4) + 755.5944925816235/(2. + n) + 43.07262314317838*lm13m1(n,S1,S2,S3)
    elif variation == 8:
        fit = 2.6264350142567814/np.power(-1. + n,2) - 832.4818430533794/(-1. + n) + 608.6363460583859/np.power(n,3) + 773.8353390059995/(2. + n) - 41.76468402930814*lm13m1(n,S1,S2,S3)
    elif variation == 9:
        fit = 160.72672912659135/np.power(-1. + n,2) - 1380.437517169532/(-1. + n) + 1313.9641564742117/np.power(n,2) + 1244.7740838194043/(2. + n) - 107.25986487346194*lm13m1(n,S1,S2,S3)
    elif variation == 10:
        fit = -4.4051195549716065/np.power(-1. + n,2) - 664.9007816190623/(-1. + n) + 517.4939352213107/(2. + n) + 338.0012780657685*lm11m1(n,S1) - 130.02563798413794*lm13m1(n,S1,S2,S3)
    elif variation == 11:
        fit = 315.51530441621395/np.power(-1. + n,2) - 681.9096023524954/(-1. + n) - 4371.86464036536/np.power(n,4) - 743.2670270884392*lm12m1(n,S1,S2) - 739.8725231366963*lm13m1(n,S1,S2,S3)
    elif variation == 12:
        fit = 18.90357718091744/np.power(-1. + n,2) - 488.3516827637743/(-1. + n) - 994.6418190719808/np.power(n,3) - 713.9439257405169*lm12m1(n,S1,S2) - 570.3417703743911*lm13m1(n,S1,S2,S3)
    elif variation == 13:
        fit = -86.56896957695098/np.power(-1. + n,2) - 275.828688059755/(-1. + n) - 824.8930651290783/np.power(n,2) - 441.1754981260873*lm12m1(n,S1,S2) - 327.27714570223736*lm13m1(n,S1,S2,S3)
    elif variation == 14:
        fit = 178.2805625979371/np.power(-1. + n,2) - 1175.763607295771/(-1. + n) - 4336.094528843359*lm11m1(n,S1) - 3747.9378120594934*lm12m1(n,S1,S2) - 1684.3286865084197*lm13m1(n,S1,S2,S3)
    elif variation == 15:
        fit = -673.7742132225945/np.power(-1. + n,2) + 317.2132626956936/(-1. + n) + 6384.686015786331/np.power(n,4) - 2029.5697078635478/np.power(n,2) + 275.27854922027643*lm13m1(n,S1,S2,S3)
    elif variation == 16:
        fit = 349.4631362634346/np.power(-1. + n,2) - 559.7446717031943/(-1. + n) - 5453.335146329048/np.power(n,4) + 1072.6220342502565*lm11m1(n,S1) - 506.2418943583583*lm13m1(n,S1,S2,S3)
    elif variation == 17:
        fit = -257.1602061122679/np.power(-1. + n,2) + 67.90588148648591/(-1. + n) + 1608.7331067743435/np.power(n,3) - 2159.0746347923864/np.power(n,2) + 65.85543860914298*lm13m1(n,S1,S2,S3)
    elif variation == 18:
        fit = -18.600199987013553/np.power(-1. + n,2) - 326.59342404939514/(-1. + n) - 1228.6958454214596/np.power(n,3) + 1020.3475901067098*lm11m1(n,S1) - 308.20406610462027*lm13m1(n,S1,S2,S3)
    elif variation == 19:
        fit = -121.90417458800518/np.power(-1. + n,2) - 155.76283554846327/(-1. + n) - 934.9471223483207/np.power(n,2) + 578.5050396951302*lm11m1(n,S1) - 146.22455326916472*lm13m1(n,S1,S2,S3)
    else:
        fit = -34.631097341548454/np.power(-1. + n,2) - 614.62987509215/(-1. + n) + 298.9931463234356/np.power(n,4) + 87.57428451895092/np.power(n,3) - 243.92212492942747/np.power(n,2) + 135.41924886509895/(1. + n) + 262.60049987311237/(2. + n) - 38.88382719169835*lm11m1(n,S1) - 334.9887739215079*lm12m1(n,S1,S2) - 251.2295891027122*lm13m1(n,S1,S2,S3)
    return common + fit


@nb.njit(cache=True)
def gamma_gg_nf0(n, cache, variation):
    r"""Return the part proportional to :math:`nf^0` of :math:`\gamma_{gg}^{(3)}`.

    Parameters
    ----------
    n : complex
        Mellin moment
    cache: numpy.ndarray
        Harmonic sum cache
    variation : int
        |N3LO| anomalous dimension variation

    Returns
    -------
    complex
        |N3LO| non-singlet anomalous dimension :math:`\gamma_{gg}^{(3)}|_{nf^0}`

    """
    S1 = c.get(c.S1, cache, n)
    S2 = c.get(c.S2, cache, n)
    S3 = c.get(c.S3, cache, n)
    common = -68587.9129845144 - 49851.703887834694/np.power(-1. + n,4) + 213823.9810748423/np.power(-1. + n,3) - 103680./np.power(n,7) - 17280./np.power(n,6) - 627978.8224813186/np.power(n,5) - 54482.80778086425/n + 40880.33011934297*S1 - 85814.12027987762*lm11(n,S1)
    if variation == 1:
        fit = -295448.0379235009/np.power(-1. + n,2) + 224578.11757296775/(-1. + n) - 526757.6738519811/(1. + n) + 296021.5646034255/(2. + n) + 2224.0922337045213*lm13m1(n,S1,S2,S3)
    elif variation == 2:
        fit = -285107.088545888/np.power(-1. + n,2) + 195545.1200082606/(-1. + n) - 252769.2783475656/(1. + n) - 108776.38581520668*lm12m1(n,S1,S2) - 65914.13979179235*lm13m1(n,S1,S2,S3)
    elif variation == 3:
        fit = -391716.7896443467/np.power(-1. + n,2) + 170902.9255344149/(-1. + n) + 1.607519634683242e6/np.power(n,4) - 89387.05777989682/(1. + n) + 76364.75507676331*lm13m1(n,S1,S2,S3)
    elif variation == 4:
        fit = -282383.73363518645/np.power(-1. + n,2) + 89190.37336362494/(-1. + n) + 405966.0728943653/np.power(n,3) - 71410.64232788606/(1. + n) + 22824.74956225227*lm13m1(n,S1,S2,S3)
    elif variation == 5:
        fit = -290139.8534816189/np.power(-1. + n,2) + 209612.58483575174/(-1. + n) - 238124.94028671857/(1. + n) + 142906.92425938678*lm11m1(n,S1) - 22034.409788754692*lm13m1(n,S1,S2,S3)
    elif variation == 6:
        fit = -275566.9972336391/np.power(-1. + n,2) + 168760.59203878703/(-1. + n) - 273096.0817605587/(2. + n) - 209128.55034080063*lm12m1(n,S1,S2) - 128775.38508377109*lm13m1(n,S1,S2,S3)
    elif variation == 7:
        fit = -411391.59210307786/np.power(-1. + n,2) + 159933.1271168039/(-1. + n) + 1.9360543948787057e6/np.power(n,4) - 60499.02697383511/(2. + n) + 91517.15779852161*lm13m1(n,S1,S2,S3)
    elif variation == 8:
        fit = -280334.89989693864/np.power(-1. + n,2) + 67957.93940012196/(-1. + n) + 469632.45484412194/np.power(n,3) - 46424.130625098995/(2. + n) + 26055.48583672462*lm13m1(n,S1,S2,S3)
    elif variation == 9:
        fit = -158342.46596423967/np.power(-1. + n,2) - 354852.44655132474/(-1. + n) + 1.0138734178112751e6/np.power(n,2) + 316958.89807541796/(2. + n) - 24481.5265510284*lm13m1(n,S1,S2,S3)
    elif variation == 10:
        fit = -285760.5473383797/np.power(-1. + n,2) + 197265.86814370425/(-1. + n) - 244220.80103026525/(2. + n) + 260806.5899887168*lm11m1(n,S1) - 42047.920641263154*lm13m1(n,S1,S2,S3)
    elif variation == 11:
        fit = -450043.3779284024/np.power(-1. + n,2) + 157421.08366934053/(-1. + n) + 2.4869999720694227e6/np.power(n,4) + 59511.9900450049*lm12m1(n,S1,S2) + 154206.10006698*lm13m1(n,S1,S2,S3)
    elif variation == 12:
        fit = -281311.4024370307/np.power(-1. + n,2) + 47312.79345234101/(-1. + n) + 565816.73490305/np.power(n,3) + 42831.109406509524*lm12m1(n,S1,S2) + 57766.0196738513*lm13m1(n,S1,S2,S3)
    elif variation == 13:
        fit = -221311.7815844328/np.power(-1. + n,2) - 73584.06072125914/(-1. + n) + 469252.6413087417/np.power(n,2) - 112337.25184482028*lm12m1(n,S1,S2) - 80504.89319687682*lm13m1(n,S1,S2,S3)
    elif variation == 14:
        fit = -371975.3618425755/np.power(-1. + n,2) + 438357.2510794566/(-1. + n) + 2.4666516141772955e6*lm11m1(n,S1) + 1.7687634818009005e6*lm12m1(n,S1,S2) + 691473.981199157*lm13m1(n,S1,S2,S3)
    elif variation == 15:
        fit = -370832.83073654736/np.power(-1. + n,2) + 77423.19888297348/(-1. + n) + 1.6257432335929913e6/np.power(n,4) + 162503.82143718746/np.power(n,2) + 72924.86692930982*lm13m1(n,S1,S2,S3)
    elif variation == 16:
        fit = -452761.5168438991/np.power(-1. + n,2) + 147639.56791297536/(-1. + n) + 2.573591277265509e6/np.power(n,4) - 85882.82474255121*lm11m1(n,S1) + 135499.7359376153*lm13m1(n,S1,S2,S3)
    elif variation == 17:
        fit = -264749.7122550716/np.power(-1. + n,2) + 13941.645196000183/(-1. + n) + 409634.3902470049/np.power(n,3) + 129527.76620894097/np.power(n,2) + 19599.111490094336*lm13m1(n,S1,S2,S3)
    elif variation == 18:
        fit = -279061.4660973225/np.power(-1. + n,2) + 37608.549986420694/(-1. + n) + 579858.1648363634/np.power(n,3) - 61212.957613155806*lm11m1(n,S1) + 42039.78644131242*lm13m1(n,S1,S2,S3)
    elif variation == 19:
        fit = -230309.24368551886/np.power(-1. + n,2) - 43011.492732260434/(-1. + n) + 441229.3934290683/np.power(n,2) + 147305.70173040565*lm11m1(n,S1) - 34403.17005106444*lm13m1(n,S1,S2,S3)
    else:
        fit = -309397.2999567167/np.power(-1. + n,2) + 101684.3546415316/(-1. + n) + 538416.2374994669/np.power(n,4) + 127942.51672236343/np.power(n,3) + 116651.94948395861/np.power(n,2) - 62023.66276810779/(1. + n) - 592.6093532060254/(2. + n) + 151082.8972526367*lm11m1(n,S1) + 75834.96806587302*lm12m1(n,S1,S2) + 52333.389323249234*lm13m1(n,S1,S2,S3)
    return common + fit


@nb.njit(cache=True)
def gamma_gg(n, nf, cache, variation):
    r"""Compute the |N3LO| gluon-gluon singlet anomalous dimension.

    Parameters
    ----------
    n : complex
        Mellin moment
    nf : int
        Number of active flavors
    cache: numpy.ndarray
        Harmonic sum cache
    variation : int
        |N3LO| anomalous dimension variation

    Returns
    -------
    complex
        |N3LO| gluon-gluon singlet anomalous dimension
        :math:`\gamma_{gg}^{(3)}(N)`

    """
    return (
        gamma_gg_nf0(n, cache, variation)
        + nf * gamma_gg_nf1(n, cache, variation)
        + nf**2 * gamma_gg_nf2(n, cache, variation)
        + nf**3 * gamma_gg_nf3(n, cache)
    )
