Input & Output
==============

Input
-----

The input is split into two runcards: a **theory runcard** and an **operator runcard**.
Note that we are not assuming any default values for the keywords, but instead the user has to provide
the full definition.

The theory card defines the general setup of the calculation, such as used perturbative orders or heavy quark masses.
Please see :class:`~eko.io.runcards.TheoryCard` for the actual format.

.. Operator Runcard
.. ^^^^^^^^^^^^^^^^

.. .. autoclass:: eko.io.runcards::OperatorCard
..    :members:
..    :no-index:

Output
------


Since the final |EKO| is a rank 4-tensor we store in the output all the different grids
for each dimension:``targetpids,targetgrid,inputpids,inputgrid``.
The ``Q2grid`` values are the actual tensor for the requested :math:`Q^2`. Each of them contains two keys:

- ``operators`` a :py:obj:`dict` with all evolution kernel operators where the key indicates which distribution is generated by which other one
  and the value represents the eko in matrix representation - this can either be the plain list representation or the binary representation
  (as provided by :py:meth:`numpy.ndarray.tobytes`)
- ``errors`` a :py:obj:`dict` with the integration errors associated to the respective operators following the same conventions as
  the ``operator`` dictionary

Each element (|EKO|) is a rank-4 tensor with the indices ordered in the following way: ``EKO[pid_out][x_out][pid_in][x_in]`` where ``pid_out`` and ``x_out``
refer to the outgoing |PDF| and ``pid_in`` and ``x_in`` to the incoming |PDF|. The ordering of ``pid_out/pid_in`` is determined by the ``targetpids/inputpids``
parameter of the output and the order of ``x_out/x_in`` by ``targetgrid/inputgrid``.

To further explore how an :class:`~eko.output.Output` object looks like
you can follow :doc:`this tutorial </overview/tutorials/output>`.
